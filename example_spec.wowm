#tag_all versions "1.12";

enum RealmType : u32 {
    PLAYER_VERSUS_ENVIRONMENT = 0;
    PLAYER_VERSUS_PLAYER = 1;
    ROLEPLAYING = 6;
    ROLEPLAYING_PLAYER_VERSUS_PLAYER = 8;
}

login Thing {
    u8 first;
}

struct Realm {
    u8 first;
    RealmType second;
    u32 third;
    u32 padding = 0;
    RealmType[4] fourth;
    u8 number_of_fifths;
    u8_be[number_of_fifths] fifths;
    RealmType[number_of_fifths] sixths;
    CString mystring;
    String[first] realstring;
}

struct IfTest {
    RealmType first;
    if (first == ROLEPLAYING) {
        u8 second;
    }
}

enum Thingie : u8 {
    SUCCESS = 0;
    FAILURE = 1;
    OTHER = self;
}

enum Thang : u8 {
    SUCCESS = 0;
    FAILURE = 1;
}

enum Population : u32 {
    GREEN_RECOMMENDED = 0x43480000;
    RED_FULL = 0x43c80000;
    BLUE_RECOMMENDED = 0x44160000;
    VALUE = self {
        comment: "Client does calculations to figure out realm pop if specific enumerator values aren't chosen.";
    }
} {
    comment: "This is.";
}

flag TestFlag : u8 {
    TING = 0x0;
    TANG = 0x1;
}

flag RealmFlag : u8 {
    NONE = 0x0;
    INVALID = 0x1;
    OFFLINE = 0x2;
    FORCE_RECOMMENDED = 0x20;
    FORCE_NEW_PLAYERS = 0x40;
    FORCE_FULL = 0x80 {
        comment: "Forces realm to show up as FULL in red text.";
    }
}




























login CMD_AUTH_LOGON_CHALLENGE_Client {
    u8 opcode {
        comment: "0x00 for CMD_AUTH_LOGON_CHALLENGE 0x02 for CMD_AUTH_RECONNECT_CHALLENGE";
    }
    u8 protocol_version {
        comment: "Exact purpose unknown. See table in #Protocol Versions.";
    }
    u32_be game_name {
        comment: "Always null terminated 'WoW\0' string.";
    }
    u8[3] version {
        comment: "[0x01, 0x01, 0x02] for 1.1.2. [0x01, 0x0C, 0x01] for 1.12.1.";
    }
    u16 build {
        comment: "4125, aka [[Rev|Revision]]";
    }
    u8[4] platform {
        comment: "eg '\\0x86'. Has a leading zero for 'x86'.";
    }
    u8[4] os {
        comment: "eg '\\0Win'. Has a leading zero for 'Win'.";
    }
    u8[4] locale {
        comment: "eg 'enUS'";
    }
    u32 timezone_offset {
        comment: "Offset in minutes from UTC time, eg. 180 means 180 minutes.";
    }
    u32_be ip_address {
        comment: "client_ip";
    }
    u8 name_length {
        comment: "Length of the account_name field in bytes. The client can only send 16 characters, but this can still be more than 16 bytes if non-ASCII characters are used.";
    }
    u8_be[name_length] name {
        comment: "UTF-8 encoded uppercase string of the username. Not all unicode characters are uppercased correctly. ";
    }
}

struct Realm {
    RealmType realm_type;
    u8 padding = 0 {
        comment: "This is a type of padding.";
    }
    RealmFlag flags;
    CString realm_name;
    CString address;
    Population population {
        comment: "Population is out of control";
    }
    u8 number_of_characters_on_realm;
    u8 category;
    u8 id;
    if (id == 0) {
        u8 second_id;
        if (second_id == 0) {
            u16 fourth_id;
        }
        else {
            u8 fourth_id_second;
        }
        u8 third_id {
            comment: "This is a comment.";
        }
    }
    if (flags == INVALID) {
        CString address;
    }
} {
    login: "This is a struct login.";
}

login CMD_REALM_LIST_Server 
{
    u8 opcode = 0x10;
    u16 size = self;
    u32 padding = 0;
    u8 number_of_realms;
    Realm[number_of_realms] realms;
    u8[10] things;
    u16 padding = 0;
} {
    comment: "This is a comment";
}

enum UpdateType : u8 {
    PARTIAL = 0;
    MOVEMENT = 1;
    CREATE_OBJECT = 2;
    FAR_OBJECTS = 3;
    NEAR_OBJECTS = 4;
}

