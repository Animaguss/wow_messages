use crate::container::Container;
use crate::file_utils::{append_string_to_file, create_or_append, write_string_to_file};
use crate::parser::enumerator::Definer;
use crate::parser::types::tags::{LoginVersion, Tags, WorldVersion};
use crate::parser::types::{Endianness, IntegerType};
use crate::wowm_printer::{get_definer_wowm_definition, get_struct_wowm_definition};
use std::fmt::Write;
use std::fs::read_to_string;
use std::path::Path;

pub struct DocWriter {
    name: String,
    inner: String,
}

impl DocWriter {
    pub fn name(&self) -> &str {
        &self.name
    }

    pub fn inner(&self) -> &str {
        &self.inner
    }

    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            inner: String::with_capacity(8000),
        }
    }

    pub fn w(&mut self, s: impl AsRef<str>) {
        self.inner.write_str(s.as_ref()).unwrap();
    }

    pub fn newline(&mut self) {
        self.w("\n");
    }

    pub fn wln(&mut self, s: impl AsRef<str>) {
        self.w(s);
        self.newline();
    }
}

pub fn print_docs_summary_and_objects(definers: &[DocWriter], containers: &[DocWriter]) {
    const DEFINER_HEADER: &str = "# Autogenerated Docs (Definers)\n";
    const CONTAINER_HEADER: &str = "# Autogenerated Docs (Containers)\n";
    const SUMMARY_PATH: &str = "wowm_language/src/SUMMARY.md";

    let s = read_to_string(SUMMARY_PATH).unwrap();
    let (s, _) = s.split_once(DEFINER_HEADER).unwrap();
    let mut s = s.to_string();
    s.push_str(DEFINER_HEADER);

    let mut already_added_files = Vec::new();

    for definer in definers {
        let path = format!(
            "docs/definer/{lower_name}.md",
            lower_name = definer.name().to_lowercase()
        );

        create_or_append(
            definer.inner(),
            Path::new(&("wowm_language/src/".to_string() + &path)),
        );

        if already_added_files.contains(&path) {
            continue;
        }

        s.write_fmt(format_args!(
            "- [{name}]({path})\n",
            name = definer.name(),
            path = path,
        ))
        .unwrap();

        already_added_files.push(path);
    }

    s.push('\n');
    s.push_str(CONTAINER_HEADER);
    for container in containers {
        let path = format!(
            "docs/container/{lower_name}.md",
            lower_name = container.name().to_lowercase()
        );

        create_or_append(
            container.inner(),
            Path::new(&("wowm_language/src/".to_string() + &path)),
        );

        if already_added_files.contains(&path) {
            continue;
        }

        s.write_fmt(format_args!(
            "- [{name}]({path})\n",
            name = container.name(),
            path = path,
        ))
        .unwrap();

        already_added_files.push(path);
    }

    write_string_to_file(&s, Path::new(SUMMARY_PATH))
}

fn common(s: &mut DocWriter, tags: &Tags) {
    print_versions(s, tags.logon_versions(), tags.versions());

    print_metadata(s, tags);
}

fn print_metadata(s: &mut DocWriter, tags: &Tags) {}

fn print_versions(
    s: &mut DocWriter,
    login_versions: &[LoginVersion],
    world_versions: &[WorldVersion],
) {
    s.w("## ");

    for (i, l) in login_versions.iter().enumerate() {
        s.w(format!("Protocol Version {}", l.to_string()));
        if i != login_versions.len() - 1 {
            s.w(format!(", "));
        }
    }

    for (i, l) in world_versions.iter().enumerate() {
        s.w(format!("Client Version {}", l.to_string()));
        if i != world_versions.len() - 1 {
            s.w(format!(", "));
        }
    }

    s.newline();
    s.newline();
}

pub fn print_docs_for_enum(e: &Definer) -> DocWriter {
    let mut s = DocWriter::new(e.name());

    common(&mut s, e.tags());

    s.wln("## Wowm Representation");
    s.wln("```rust,ignore");
    s.wln(get_definer_wowm_definition("enum", e, ""));
    s.wln("```");

    print_definer_table(&mut s, e);

    s
}

pub fn print_docs_for_flag(e: &Definer) -> DocWriter {
    let mut s = DocWriter::new(e.name());

    common(&mut s, e.tags());

    s.wln("## Wowm Representation");
    s.wln("```rust,ignore");
    s.wln(get_definer_wowm_definition("flag", e, ""));
    s.wln("```");

    print_definer_table(&mut s, e);

    s
}

pub fn print_docs_for_container(e: &Container) -> DocWriter {
    let mut s = DocWriter::new(e.name());

    common(&mut s, e.tags());

    s.wln("## Wowm Representation");
    s.wln("```rust,ignore");
    s.wln(get_struct_wowm_definition(e, ""));
    s.wln("```");

    s
}

fn print_definer_table(s: &mut DocWriter, e: &Definer) {
    s.wln("## Type");
    s.wln(format!(
        "The basic type is `{ty_str}`, a {byte} byte ({bit} bit){endian} integer.",
        ty_str = e.ty().str(),
        byte = e.ty().size(),
        bit = e.ty().size() * 8,
        endian = match e.ty() {
            IntegerType::U8 => "".to_string(),
            IntegerType::U16(e) | IntegerType::U32(e) | IntegerType::U64(e) => format!(
                " {} endian",
                match e {
                    Endianness::Little => "little",
                    Endianness::Big => "big",
                }
            ),
        }
    ));

    s.wln("## Enumerators");

    let any_fields_has_display = e.fields().iter().any(|f| f.tags().display().is_some());

    s.w("| Enumerator | Original  | Description | Comment |");
    if any_fields_has_display {
        s.wln(" Display |");
    } else {
        s.newline();
    }

    s.w("| --------- | -------- | ----------- | ------- |");
    if any_fields_has_display {
        s.wln(" ------- |");
    } else {
        s.newline();
    }

    for f in e.fields() {
        s.w(format!(
            "| `{name}` | {value} (0x{hex:0>2X}) | {description} | {comment} |",
            name = f.name(),
            value = f.value().int(),
            hex = f.value().int(),
            description = f.tags().description().unwrap_or(""),
            comment = f.tags().comment().unwrap_or(""),
        ));
        if any_fields_has_display {
            s.wln(format!(" {} |", f.tags().display().unwrap_or("")));
        } else {
            s.newline();
        }
    }
}
