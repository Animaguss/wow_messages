use std::convert::{TryFrom, TryInto};
use crate::world::v1::v12::{SimpleFlag};
use crate::world::v1::v12::{UpdateFlag};
use crate::{ConstantSized, MaximumPossibleSized, VariableSized};
#[cfg(feature = "async_tokio")]
use tokio::io::{AsyncReadExt, AsyncWriteExt};
#[cfg(feature = "async_std")]
use async_std::io::{ReadExt, WriteExt};

#[derive(Debug, PartialEq, Clone, Default)]
pub struct FlagIfElseIf {
    pub flags: FlagIfElseIfUpdateFlag,
}

impl FlagIfElseIf {
    pub(crate) fn read<R: std::io::Read>(r: &mut R) -> std::result::Result<Self, std::io::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::new(crate::util::read_u8_le(r)?);

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::new(crate::util::read_u8_le(r)?);

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::read_u8_le(r)?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            }
            else {
                None
            };

            let s = FlagIfElseIfSimpleFlag {
                inner: s.as_int(),
                one: s_ONE,
            };

            Some(FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        }
        else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_int(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }

    pub(crate) fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        // flags: UpdateFlag
        crate::util::write_u8_le(w, self.flags.as_int() as u8)?;

        if let Some(if_statement) = &self.flags.one_if {
            match if_statement {
                FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                    b_if,
                } => {
                    // b_if: u8
                    w.write_all(&b_if.to_le_bytes())?;

                }
                FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                    s,
                } => {
                    // s: SimpleFlag
                    crate::util::write_u8_le(w, s.as_int() as u8)?;

                    if let Some(if_statement) = &s.one {
                        // if_one: u8
                        w.write_all(&if_statement.if_one.to_le_bytes())?;

                    }

                }
                FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                    elseif2,
                } => {
                    // elseif2: u8
                    w.write_all(&elseif2.to_le_bytes())?;

                }
            }
        }

        if let Some(if_statement) = &self.flags.eight_if {
            // last_if: u8
            w.write_all(&if_statement.last_if.to_le_bytes())?;

        }

        Ok(())
    }

    pub(crate) async fn tokio_read<R: AsyncReadExt + Unpin + Send>(r: &mut R) -> std::result::Result<Self, std::io::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::new(crate::util::tokio_read_u8_le(r).await?);

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::new(crate::util::tokio_read_u8_le(r).await?);

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::tokio_read_u8_le(r).await?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            }
            else {
                None
            };

            let s = FlagIfElseIfSimpleFlag {
                inner: s.as_int(),
                one: s_ONE,
            };

            Some(FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        }
        else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_int(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }

    pub(crate) async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        // flags: UpdateFlag
        crate::util::tokio_write_u8_le(w, self.flags.as_int() as u8).await?;

        if let Some(if_statement) = &self.flags.one_if {
            match if_statement {
                FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                    b_if,
                } => {
                    // b_if: u8
                    w.write_all(&b_if.to_le_bytes()).await?;

                }
                FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                    s,
                } => {
                    // s: SimpleFlag
                    crate::util::tokio_write_u8_le(w, s.as_int() as u8).await?;

                    if let Some(if_statement) = &s.one {
                        // if_one: u8
                        w.write_all(&if_statement.if_one.to_le_bytes()).await?;

                    }

                }
                FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                    elseif2,
                } => {
                    // elseif2: u8
                    w.write_all(&elseif2.to_le_bytes()).await?;

                }
            }
        }

        if let Some(if_statement) = &self.flags.eight_if {
            // last_if: u8
            w.write_all(&if_statement.last_if.to_le_bytes()).await?;

        }

        Ok(())
    }

    pub(crate) async fn astd_read<R: ReadExt + Unpin + Send>(r: &mut R) -> std::result::Result<Self, std::io::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::new(crate::util::astd_read_u8_le(r).await?);

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::astd_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::new(crate::util::astd_read_u8_le(r).await?);

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::astd_read_u8_le(r).await?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            }
            else {
                None
            };

            let s = FlagIfElseIfSimpleFlag {
                inner: s.as_int(),
                one: s_ONE,
            };

            Some(FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::astd_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::astd_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        }
        else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_int(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }

    pub(crate) async fn astd_write<W: WriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        // flags: UpdateFlag
        crate::util::astd_write_u8_le(w, self.flags.as_int() as u8).await?;

        if let Some(if_statement) = &self.flags.one_if {
            match if_statement {
                FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                    b_if,
                } => {
                    // b_if: u8
                    w.write_all(&b_if.to_le_bytes()).await?;

                }
                FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                    s,
                } => {
                    // s: SimpleFlag
                    crate::util::astd_write_u8_le(w, s.as_int() as u8).await?;

                    if let Some(if_statement) = &s.one {
                        // if_one: u8
                        w.write_all(&if_statement.if_one.to_le_bytes()).await?;

                    }

                }
                FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                    elseif2,
                } => {
                    // elseif2: u8
                    w.write_all(&elseif2.to_le_bytes()).await?;

                }
            }
        }

        if let Some(if_statement) = &self.flags.eight_if {
            // last_if: u8
            w.write_all(&if_statement.last_if.to_le_bytes()).await?;

        }

        Ok(())
    }

}

impl VariableSized for FlagIfElseIf {
    fn size(&self) -> usize {
        0
        + self.flags.size() // flags: FlagIfElseIfUpdateFlag
    }
}

impl MaximumPossibleSized for FlagIfElseIf {
    fn maximum_possible_size() -> usize {
        0
        + 4 // flags: FlagIfElseIfUpdateFlag
    }
}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlag {
    inner: u8,
    one: Option<FlagIfElseIfSimpleFlagONE>,
}

impl FlagIfElseIfSimpleFlag {
    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one: None,
        }
    }

    pub const fn new_ZERO() -> Self {
        Self {
            inner: SimpleFlag::ZERO,
            one: None,
        }
    }

    pub fn set_ZERO(&mut self) -> Self {
        self.inner |= SimpleFlag::ZERO;
        self.clone()
    }

    pub const fn get_ZERO(&self) -> bool {
        // Underlying value is 0
        self.inner == SimpleFlag::ZERO
    }

    pub fn clear_ZERO(&mut self) -> Self {
        self.inner &= SimpleFlag::ZERO.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_ONE(one: FlagIfElseIfSimpleFlagONE) -> Self {
        Self {
            inner: SimpleFlag::ONE,
            one: Some(one),
        }
    }

    pub fn set_ONE(&mut self, one: FlagIfElseIfSimpleFlagONE) -> Self {
        self.inner |= SimpleFlag::ONE;
        self.one = Some(one);
        self.clone()
    }

    pub const fn get_ONE(&self) -> Option<&FlagIfElseIfSimpleFlagONE> {
        self.one.as_ref()
    }

    pub fn clear_ONE(&mut self) -> Self {
        self.inner &= SimpleFlag::ONE.reverse_bits();
        self.one = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_TWO() -> Self {
        Self {
            inner: SimpleFlag::TWO,
            one: None,
        }
    }

    pub fn set_TWO(&mut self) -> Self {
        self.inner |= SimpleFlag::TWO;
        self.clone()
    }

    pub const fn get_TWO(&self) -> bool {
        (self.inner & SimpleFlag::TWO) != 0
    }

    pub fn clear_TWO(&mut self) -> Self {
        self.inner &= SimpleFlag::TWO.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub(crate) const fn as_int(&self) -> u8 {
        self.inner
    }

}
impl VariableSized for FlagIfElseIfSimpleFlag {
    fn size(&self) -> usize {
        1 // inner
        + {
            if let Some(s) = &self.one {
                s.size()
            } else {
                0
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfSimpleFlag {
    fn maximum_possible_size() -> usize {
        1 // inner
        + FlagIfElseIfSimpleFlagONE::maximum_possible_size() // ONE enumerator
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlagONE {
    pub if_one: u8,
}

impl VariableSized for FlagIfElseIfSimpleFlagONE {
    fn size(&self) -> usize {
        1 // if_one: u8
    }
}

impl MaximumPossibleSized for FlagIfElseIfSimpleFlagONE {
    fn maximum_possible_size() -> usize {
        1 // if_one: u8
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FlagIfElseIfUpdateFlagONE_IF {
    ONE_IF {
        b_if: u8,
    },
    TWO_ELSEIF {
        s: FlagIfElseIfSimpleFlag,
    },
    FOUR_ELSEIF {
        elseif2: u8,
    },
}

impl FlagIfElseIfUpdateFlagONE_IF {
    pub(crate) const fn as_int(&self) -> u8 {
        match self {
            Self::ONE_IF { .. } => 1,
            Self::TWO_ELSEIF { .. } => 2,
            Self::FOUR_ELSEIF { .. } => 4,
        }
    }

}

impl VariableSized for FlagIfElseIfUpdateFlagONE_IF {
    fn size(&self) -> usize {
        match self {
            Self::ONE_IF {
                b_if,
            } => {
                0 // Not an actual enum sent over the wire
                + 1 // b_if: u8
            }
            Self::TWO_ELSEIF {
                s,
            } => {
                0 // Not an actual enum sent over the wire
                + s.size() // s: FlagIfElseIfSimpleFlag
            }
            Self::FOUR_ELSEIF {
                elseif2,
            } => {
                0 // Not an actual enum sent over the wire
                + 1 // elseif2: u8
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlagONE_IF {
    fn maximum_possible_size() -> usize {
        0
    }
}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlag {
    inner: u8,
    one_if: Option<FlagIfElseIfUpdateFlagONE_IF>,
    eight_if: Option<FlagIfElseIfUpdateFlagEIGHT_IF>,
}

impl FlagIfElseIfUpdateFlag {
    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one_if: None,
            eight_if: None,
        }
    }

    pub const fn new_NONE() -> Self {
        Self {
            inner: UpdateFlag::NONE,
            one_if: None,
            eight_if: None,
        }
    }

    pub fn set_NONE(&mut self) -> Self {
        self.inner |= UpdateFlag::NONE;
        self.clone()
    }

    pub const fn get_NONE(&self) -> bool {
        // Underlying value is 0
        self.inner == UpdateFlag::NONE
    }

    pub fn clear_NONE(&mut self) -> Self {
        self.inner &= UpdateFlag::NONE.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_ONE_IF(one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        Self {
            inner: one_if.as_int(),
            one_if: Some(one_if),
            eight_if: None,
        }
    }

    pub fn set_ONE_IF(&mut self, one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        self.inner |= one_if.as_int();
        self.one_if = Some(one_if);
        self.clone()
    }

    pub const fn get_ONE_IF(&self) -> Option<&FlagIfElseIfUpdateFlagONE_IF> {
        self.one_if.as_ref()
    }

    pub fn clear_ONE_IF(&mut self) -> Self {
        self.inner &= UpdateFlag::ONE_IF.reverse_bits();
        self.one_if = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_EIGHT_IF(eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        Self {
            inner: UpdateFlag::EIGHT_IF,
            one_if: None,
            eight_if: Some(eight_if),
        }
    }

    pub fn set_EIGHT_IF(&mut self, eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        self.inner |= UpdateFlag::EIGHT_IF;
        self.eight_if = Some(eight_if);
        self.clone()
    }

    pub const fn get_EIGHT_IF(&self) -> Option<&FlagIfElseIfUpdateFlagEIGHT_IF> {
        self.eight_if.as_ref()
    }

    pub fn clear_EIGHT_IF(&mut self) -> Self {
        self.inner &= UpdateFlag::EIGHT_IF.reverse_bits();
        self.eight_if = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub(crate) const fn as_int(&self) -> u8 {
        self.inner
    }

}
impl VariableSized for FlagIfElseIfUpdateFlag {
    fn size(&self) -> usize {
        1 // inner
        + {
            if let Some(s) = &self.one_if {
                s.size()
            } else {
                0
            }
        }
        + {
            if let Some(s) = &self.eight_if {
                s.size()
            } else {
                0
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlag {
    fn maximum_possible_size() -> usize {
        1 // inner
        + FlagIfElseIfUpdateFlagONE_IF::maximum_possible_size() // ONE_IF enumerator
        + FlagIfElseIfUpdateFlagEIGHT_IF::maximum_possible_size() // EIGHT_IF enumerator
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlagEIGHT_IF {
    pub last_if: u8,
}

impl VariableSized for FlagIfElseIfUpdateFlagEIGHT_IF {
    fn size(&self) -> usize {
        1 // last_if: u8
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlagEIGHT_IF {
    fn maximum_possible_size() -> usize {
        1 // last_if: u8
    }
}

