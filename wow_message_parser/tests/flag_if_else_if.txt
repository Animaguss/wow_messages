use std::convert::{TryFrom, TryInto};
use crate::world::v1::v12::{SimpleFlag};
use crate::world::v1::v12::{UpdateFlag};
use crate::{ConstantSized, MaximumPossibleSized, ReadableAndWritable, VariableSized};
#[cfg(any(feature = "async_tokio", feature = "async_std"))]
use crate::AsyncReadWrite;
#[cfg(any(feature = "async_tokio", feature = "async_std"))]
use async_trait::async_trait;
#[cfg(feature = "async_tokio")]
use tokio::io::{AsyncReadExt, AsyncWriteExt};

#[derive(Debug, PartialEq, Clone, Default)]
pub struct FlagIfElseIf {
    pub flags: FlagIfElseIfUpdateFlag,
}

impl ReadableAndWritable for FlagIfElseIf {
    type Error = std::io::Error;

    fn read<R: std::io::Read>(r: &mut R) -> std::result::Result<Self, Self::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::read(r)?;

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlag_ONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::read(r)?;

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::read_u8_le(r)?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            } else {
                None
            };

            Some(FlagIfElseIfUpdateFlag_ONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlag_ONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        } else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_u8(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }

    fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        // flags: UpdateFlag
        self.flags.write(w)?;

        if let Some(s) = &self.flags.one_if {
            s.write(w)?;
        }

        if let Some(s) = &self.flags.eight_if {
            s.write(w)?;
        }

        Ok(())
    }

}

#[cfg(any(feature = "async_tokio", feature = "async_std"))]
#[async_trait]
impl AsyncReadWrite for FlagIfElseIf {
    type Error = std::io::Error;
    #[cfg(feature = "async_tokio")]
    async fn tokio_read<R: AsyncReadExt + Unpin + Send>(r: &mut R) -> Result<Self, Self::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::tokio_read(r).await?;

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlag_ONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::tokio_read(r).await?;

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::tokio_read_u8_le(r).await?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            } else {
                None
            };

            Some(FlagIfElseIfUpdateFlag_ONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlag_ONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::tokio_read_u8_le(r).await?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        } else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_u8(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }
    #[cfg(feature = "async_tokio")]
    async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> Result<(), std::io::Error> {
        // flags: UpdateFlag
        self.flags.tokio_write(w).await?;

        if let Some(s) = &self.flags.one_if {
            s.tokio_write(w).await?;
        }

        if let Some(s) = &self.flags.eight_if {
            s.tokio_write(w).await?;
        }

        Ok(())
    }
}
impl VariableSized for FlagIfElseIf {
    fn size(&self) -> usize {
        self.flags.size() // flags: UpdateFlag and subfields
    }
}

impl MaximumPossibleSized for FlagIfElseIf {
    fn maximum_possible_size() -> usize {
        UpdateFlag::maximum_possible_size() // flags: UpdateFlag
    }
}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlag {
    inner: u8,
    one: Option<FlagIfElseIfSimpleFlagONE>,
}

impl From<&FlagIfElseIfSimpleFlag> for SimpleFlag {
    fn from(e: &FlagIfElseIfSimpleFlag) -> Self {
        Self::new(e.inner)
    }
}

impl FlagIfElseIfSimpleFlag {
    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        let a: SimpleFlag = self.into();
        a.write(w)?;
        Ok(())
    }

    pub async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        let a: SimpleFlag = self.into();
        a.tokio_write(w).await?;
        Ok(())
    }

    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one: None,
        }
    }

    pub const fn new_ZERO() -> Self {
        Self {
            inner: SimpleFlag::ZERO,
            one: None,
        }
    }

    pub fn set_ZERO(&mut self) -> Self {
        self.inner |= SimpleFlag::ZERO;
        self.clone()
    }

    pub const fn get_ZERO(&self) -> bool {
        // Underlying value is 0
        self.inner == SimpleFlag::ZERO
    }

    pub fn clear_ZERO(&mut self) -> Self {
        self.inner &= SimpleFlag::ZERO.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_ONE(one: FlagIfElseIfSimpleFlagONE) -> Self {
        Self {
            inner: SimpleFlag::ONE,
            one: Some(one),
        }
    }

    pub fn set_ONE(&mut self, one: FlagIfElseIfSimpleFlagONE) -> Self {
        self.inner |= SimpleFlag::ONE;
        self.one = Some(one);
        self.clone()
    }

    pub const fn get_ONE(&self) -> Option<&FlagIfElseIfSimpleFlagONE> {
        self.one.as_ref()
    }

    pub fn clear_ONE(&mut self) -> Self {
        self.inner &= SimpleFlag::ONE.reverse_bits();
        self.one = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_TWO() -> Self {
        Self {
            inner: SimpleFlag::TWO,
            one: None,
        }
    }

    pub fn set_TWO(&mut self) -> Self {
        self.inner |= SimpleFlag::TWO;
        self.clone()
    }

    pub const fn get_TWO(&self) -> bool {
        (self.inner & SimpleFlag::TWO) != 0
    }

    pub fn clear_TWO(&mut self) -> Self {
        self.inner &= SimpleFlag::TWO.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

}
impl VariableSized for FlagIfElseIfSimpleFlag {
    fn size(&self) -> usize {
        1 // inner: SimpleFlag (u8)
        + {
            if let Some(s) = &self.one {
                s.size()
            } else {
                0
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfSimpleFlag {
    fn maximum_possible_size() -> usize {
        1 // inner: SimpleFlag (u8)
        + FlagIfElseIfSimpleFlagONE::maximum_possible_size() // ONE enumerator
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlagONE {
    pub if_one: u8,
}

impl VariableSized for FlagIfElseIfSimpleFlagONE {
    fn size(&self) -> usize {
        1 // if_one: u8
    }
}

impl MaximumPossibleSized for FlagIfElseIfSimpleFlagONE {
    fn maximum_possible_size() -> usize {
        1 // if_one: u8
    }
}

impl FlagIfElseIfSimpleFlagONE {
    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        w.write_all(&self.if_one.to_le_bytes())?;

        Ok(())
    }

}

#[cfg(any(feature = "async_tokio", feature = "async_std"))]
impl FlagIfElseIfSimpleFlagONE {
    #[cfg(feature = "async_tokio")]
    async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        w.write_all(&self.if_one.to_le_bytes()).await?;

        Ok(())
    }

}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlag {
    inner: u8,
    one_if: Option<FlagIfElseIfUpdateFlagONE_IF>,
    eight_if: Option<FlagIfElseIfUpdateFlagEIGHT_IF>,
}

impl From<&FlagIfElseIfUpdateFlag> for UpdateFlag {
    fn from(e: &FlagIfElseIfUpdateFlag) -> Self {
        Self::new(e.inner)
    }
}

impl FlagIfElseIfUpdateFlag {
    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        let a: UpdateFlag = self.into();
        a.write(w)?;
        Ok(())
    }

    pub async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        let a: UpdateFlag = self.into();
        a.tokio_write(w).await?;
        Ok(())
    }

    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one_if: None,
            eight_if: None,
        }
    }

    pub const fn new_NONE() -> Self {
        Self {
            inner: UpdateFlag::NONE,
            one_if: None,
            eight_if: None,
        }
    }

    pub fn set_NONE(&mut self) -> Self {
        self.inner |= UpdateFlag::NONE;
        self.clone()
    }

    pub const fn get_NONE(&self) -> bool {
        // Underlying value is 0
        self.inner == UpdateFlag::NONE
    }

    pub fn clear_NONE(&mut self) -> Self {
        self.inner &= UpdateFlag::NONE.reverse_bits();
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_ONE_IF(one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        Self {
            inner: UpdateFlag::ONE_IF,
            one_if: Some(one_if),
            eight_if: None,
        }
    }

    pub fn set_ONE_IF(&mut self, one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        self.inner |= UpdateFlag::ONE_IF;
        self.one_if = Some(one_if);
        self.clone()
    }

    pub const fn get_ONE_IF(&self) -> Option<&FlagIfElseIfUpdateFlagONE_IF> {
        self.one_if.as_ref()
    }

    pub fn clear_ONE_IF(&mut self) -> Self {
        self.inner &= UpdateFlag::ONE_IF.reverse_bits();
        self.one_if = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_TWO_ELSEIF(two_elseif: FlagIfElseIfUpdateFlagTWO_ELSEIF) -> Self {
        Self {
            inner: UpdateFlag::TWO_ELSEIF,
            one_if: None,
            eight_if: None,
        }
    }

    pub fn set_TWO_ELSEIF(&mut self, two_elseif: FlagIfElseIfUpdateFlagTWO_ELSEIF) -> Self {
        self.inner |= UpdateFlag::TWO_ELSEIF;
        self.two_elseif = Some(two_elseif);
        self.clone()
    }

    pub const fn get_TWO_ELSEIF(&self) -> Option<&FlagIfElseIfUpdateFlagTWO_ELSEIF> {
        self.two_elseif.as_ref()
    }

    pub fn clear_TWO_ELSEIF(&mut self) -> Self {
        self.inner &= UpdateFlag::TWO_ELSEIF.reverse_bits();
        self.two_elseif = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_FOUR_ELSEIF(four_elseif: FlagIfElseIfUpdateFlagFOUR_ELSEIF) -> Self {
        Self {
            inner: UpdateFlag::FOUR_ELSEIF,
            one_if: None,
            eight_if: None,
        }
    }

    pub fn set_FOUR_ELSEIF(&mut self, four_elseif: FlagIfElseIfUpdateFlagFOUR_ELSEIF) -> Self {
        self.inner |= UpdateFlag::FOUR_ELSEIF;
        self.four_elseif = Some(four_elseif);
        self.clone()
    }

    pub const fn get_FOUR_ELSEIF(&self) -> Option<&FlagIfElseIfUpdateFlagFOUR_ELSEIF> {
        self.four_elseif.as_ref()
    }

    pub fn clear_FOUR_ELSEIF(&mut self) -> Self {
        self.inner &= UpdateFlag::FOUR_ELSEIF.reverse_bits();
        self.four_elseif = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

    pub const fn new_EIGHT_IF(eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        Self {
            inner: UpdateFlag::EIGHT_IF,
            one_if: None,
            eight_if: Some(eight_if),
        }
    }

    pub fn set_EIGHT_IF(&mut self, eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        self.inner |= UpdateFlag::EIGHT_IF;
        self.eight_if = Some(eight_if);
        self.clone()
    }

    pub const fn get_EIGHT_IF(&self) -> Option<&FlagIfElseIfUpdateFlagEIGHT_IF> {
        self.eight_if.as_ref()
    }

    pub fn clear_EIGHT_IF(&mut self) -> Self {
        self.inner &= UpdateFlag::EIGHT_IF.reverse_bits();
        self.eight_if = None;
        // TODO: Cloning like this is not conductive to good performance but it is
        // temporarily necessary due to test syntax
        self.clone()
    }

}
impl VariableSized for FlagIfElseIfUpdateFlag {
    fn size(&self) -> usize {
        1 // inner: UpdateFlag (u8)
        + {
            if let Some(s) = &self.one_if {
                s.size()
            } else {
                0
            }
        }
        + {
            if let Some(s) = &self.eight_if {
                s.size()
            } else {
                0
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlag {
    fn maximum_possible_size() -> usize {
        1 // inner: UpdateFlag (u8)
        + FlagIfElseIfUpdateFlagONE_IF::maximum_possible_size() // ONE_IF enumerator
        + FlagIfElseIfUpdateFlagEIGHT_IF::maximum_possible_size() // EIGHT_IF enumerator
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FlagIfElseIfUpdateFlagONE_IF {
    ONE_IF {
        b_if: u8,
    },
    TWO_ELSEIF {
        s: SimpleFlag,
    },
    FOUR_ELSEIF {
        elseif2: u8,
    },
}

impl VariableSized for FlagIfElseIfUpdateFlagONE_IF {
    fn size(&self) -> usize {
        match self {
            Self::ONE_IF => {
                1 // b_if: u8
            }
            Self::TWO_ELSEIF => {
                SimpleFlag::size() // s: SimpleFlag
                s.size() // s
            }
            Self::FOUR_ELSEIF => {
                1 // elseif2: u8
            }
        }
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlagONE_IF {
    fn maximum_possible_size() -> usize {
        65536 // TODO Flag elseif
    }
}

impl FlagIfElseIfUpdateFlagONE_IF {
    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        match &self {
            Self::ONE_IF {
                b_if,
            } => {
                // b_if: u8
                w.write_all(&b_if.to_le_bytes())?;

            }
            Self::TWO_ELSEIF {
                s,
                s
            } => {
                // s: SimpleFlag
                s.write(w)?;

                if let Some(s) = &s.one {
                    s.write(w)?;
                }

            }
            Self::FOUR_ELSEIF {
                elseif2,
            } => {
                // elseif2: u8
                w.write_all(&elseif2.to_le_bytes())?;

            }
        }

        Ok(())
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlagEIGHT_IF {
    pub last_if: u8,
}

impl VariableSized for FlagIfElseIfUpdateFlagEIGHT_IF {
    fn size(&self) -> usize {
        1 // last_if: u8
    }
}

impl MaximumPossibleSized for FlagIfElseIfUpdateFlagEIGHT_IF {
    fn maximum_possible_size() -> usize {
        1 // last_if: u8
    }
}

impl FlagIfElseIfUpdateFlagEIGHT_IF {
    pub fn write<W: std::io::Write>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        w.write_all(&self.last_if.to_le_bytes())?;

        Ok(())
    }

}

#[cfg(any(feature = "async_tokio", feature = "async_std"))]
impl FlagIfElseIfUpdateFlagEIGHT_IF {
    #[cfg(feature = "async_tokio")]
    async fn tokio_write<W: AsyncWriteExt + Unpin + Send>(&self, w: &mut W) -> std::result::Result<(), std::io::Error> {
        w.write_all(&self.last_if.to_le_bytes()).await?;

        Ok(())
    }

}

