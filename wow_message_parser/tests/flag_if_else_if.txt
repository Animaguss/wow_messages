use std::convert::{TryFrom, TryInto};
use crate::world::v1::v12::SimpleFlag;
use crate::world::v1::v12::UpdateFlag;
#[cfg(feature = "tokio")]
use tokio::io::AsyncReadExt;
#[cfg(feature = "async-std")]
use async_std::io::ReadExt;
use std::io::Write;

#[derive(Debug, PartialEq, Clone, Default)]
pub struct FlagIfElseIf {
    pub flags: FlagIfElseIfUpdateFlag,
}

impl FlagIfElseIf {
    pub(crate) fn write_into_vec(&self, w: &mut Vec<u8>) -> Result<(), std::io::Error> {
        // flags: UpdateFlag
        w.write_all(&(self.flags.as_int() as u8).to_le_bytes())?;

        if let Some(if_statement) = &self.flags.one_if {
            match if_statement {
                FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                    b_if,
                } => {
                    // b_if: u8
                    w.write_all(&b_if.to_le_bytes())?;

                }
                FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                    s,
                } => {
                    // s: SimpleFlag
                    w.write_all(&(s.as_int() as u8).to_le_bytes())?;

                    if let Some(if_statement) = &s.one {
                        // if_one: u8
                        w.write_all(&if_statement.if_one.to_le_bytes())?;

                    }

                }
                FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                    elseif2,
                } => {
                    // elseif2: u8
                    w.write_all(&elseif2.to_le_bytes())?;

                }
            }
        }

        if let Some(if_statement) = &self.flags.eight_if {
            // last_if: u8
            w.write_all(&if_statement.last_if.to_le_bytes())?;

        }

        Ok(())
    }
}

impl FlagIfElseIf {
    pub(crate) fn read<R: std::io::Read>(r: &mut R) -> std::result::Result<Self, std::io::Error> {
        // flags: UpdateFlag
        let flags = UpdateFlag::new(crate::util::read_u8_le(r)?);

        let flags_ONE_IF = if flags.is_ONE_IF() {
            // b_if: u8
            let b_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagONE_IF::ONE_IF {
                b_if,
            })
        }
        else if flags.is_TWO_ELSEIF() {
            // s: SimpleFlag
            let s = SimpleFlag::new(crate::util::read_u8_le(r)?);

            let s_ONE = if s.is_ONE() {
                // if_one: u8
                let if_one = crate::util::read_u8_le(r)?;

                Some(FlagIfElseIfSimpleFlagONE {
                    if_one,
                })
            }
            else {
                None
            };

            let s = FlagIfElseIfSimpleFlag {
                inner: s.as_int(),
                one: s_ONE,
            };

            Some(FlagIfElseIfUpdateFlagONE_IF::TWO_ELSEIF {
                s,
            })
        }
        else if flags.is_FOUR_ELSEIF() {
            // elseif2: u8
            let elseif2 = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagONE_IF::FOUR_ELSEIF {
                elseif2,
            })
        }
        else {
            None
        };

        let flags_EIGHT_IF = if flags.is_EIGHT_IF() {
            // last_if: u8
            let last_if = crate::util::read_u8_le(r)?;

            Some(FlagIfElseIfUpdateFlagEIGHT_IF {
                last_if,
            })
        }
        else {
            None
        };

        let flags = FlagIfElseIfUpdateFlag {
            inner: flags.as_int(),
            one_if: flags_ONE_IF,
            eight_if: flags_EIGHT_IF,
        };

        Ok(Self {
            flags,
        })
    }

}

impl FlagIfElseIf {
    pub(crate) fn size(&self) -> usize {
        0
        + self.flags.size() // flags: FlagIfElseIfUpdateFlag
    }
}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlag {
    inner: u8,
    one: Option<FlagIfElseIfSimpleFlagONE>,
}

impl FlagIfElseIfSimpleFlag {
    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one: None,
        }
    }

    pub const fn new_ZERO() -> Self {
        Self {
            inner: SimpleFlag::ZERO,
            one: None,
        }
    }

    pub fn set_ZERO(&mut self) -> Self {
        self.inner |= SimpleFlag::ZERO;
        self.clone()
    }

    pub const fn get_ZERO(&self) -> bool {
        // Underlying value is 0
        self.inner == SimpleFlag::ZERO
    }

    pub fn clear_ZERO(mut self) -> Self {
        self.inner &= SimpleFlag::ZERO.reverse_bits();
        self
    }

    pub const fn new_ONE(one: FlagIfElseIfSimpleFlagONE) -> Self {
        Self {
            inner: SimpleFlag::ONE,
            one: Some(one),
        }
    }

    pub fn set_ONE(&mut self, one: FlagIfElseIfSimpleFlagONE) -> Self {
        self.inner |= SimpleFlag::ONE;
        self.one = Some(one);
        self.clone()
    }

    pub const fn get_ONE(&self) -> Option<&FlagIfElseIfSimpleFlagONE> {
        self.one.as_ref()
    }

    pub fn clear_ONE(mut self) -> Self {
        self.inner &= SimpleFlag::ONE.reverse_bits();
        self.one = None;
        self
    }

    pub const fn new_TWO() -> Self {
        Self {
            inner: SimpleFlag::TWO,
            one: None,
        }
    }

    pub fn set_TWO(&mut self) -> Self {
        self.inner |= SimpleFlag::TWO;
        self.clone()
    }

    pub const fn get_TWO(&self) -> bool {
        (self.inner & SimpleFlag::TWO) != 0
    }

    pub fn clear_TWO(mut self) -> Self {
        self.inner &= SimpleFlag::TWO.reverse_bits();
        self
    }

    pub(crate) const fn as_int(&self) -> u8 {
        self.inner
    }

}
impl FlagIfElseIfSimpleFlag {
    pub(crate) fn size(&self) -> usize {
        1 // inner
        + {
            if let Some(s) = &self.one {
                s.size()
            } else {
                0
            }
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfSimpleFlagONE {
    pub if_one: u8,
}

impl FlagIfElseIfSimpleFlagONE {
    pub(crate) fn size(&self) -> usize {
        1 // if_one: u8
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum FlagIfElseIfUpdateFlagONE_IF {
    ONE_IF {
        b_if: u8,
    },
    TWO_ELSEIF {
        s: FlagIfElseIfSimpleFlag,
    },
    FOUR_ELSEIF {
        elseif2: u8,
    },
}

impl FlagIfElseIfUpdateFlagONE_IF {
    pub(crate) const fn as_int(&self) -> u8 {
        match self {
            Self::ONE_IF { .. } => 1,
            Self::TWO_ELSEIF { .. } => 2,
            Self::FOUR_ELSEIF { .. } => 4,
        }
    }

}

impl FlagIfElseIfUpdateFlagONE_IF {
    pub(crate) fn size(&self) -> usize {
        match self {
            Self::ONE_IF {
                b_if,
            } => {
                0 // Not an actual enum sent over the wire
                + 1 // b_if: u8
            }
            Self::TWO_ELSEIF {
                s,
            } => {
                0 // Not an actual enum sent over the wire
                + s.size() // s: FlagIfElseIfSimpleFlag
            }
            Self::FOUR_ELSEIF {
                elseif2,
            } => {
                0 // Not an actual enum sent over the wire
                + 1 // elseif2: u8
            }
        }
    }
}

#[derive(Default, Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlag {
    inner: u8,
    one_if: Option<FlagIfElseIfUpdateFlagONE_IF>,
    eight_if: Option<FlagIfElseIfUpdateFlagEIGHT_IF>,
}

impl FlagIfElseIfUpdateFlag {
    pub const fn empty() -> Self {
        Self {
            inner: 0,
            one_if: None,
            eight_if: None,
        }
    }

    pub const fn new_NONE() -> Self {
        Self {
            inner: UpdateFlag::NONE,
            one_if: None,
            eight_if: None,
        }
    }

    pub fn set_NONE(&mut self) -> Self {
        self.inner |= UpdateFlag::NONE;
        self.clone()
    }

    pub const fn get_NONE(&self) -> bool {
        // Underlying value is 0
        self.inner == UpdateFlag::NONE
    }

    pub fn clear_NONE(mut self) -> Self {
        self.inner &= UpdateFlag::NONE.reverse_bits();
        self
    }

    pub const fn new_ONE_IF(one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        Self {
            inner: one_if.as_int(),
            one_if: Some(one_if),
            eight_if: None,
        }
    }

    pub fn set_ONE_IF(&mut self, one_if: FlagIfElseIfUpdateFlagONE_IF) -> Self {
        self.inner |= one_if.as_int();
        self.one_if = Some(one_if);
        self.clone()
    }

    pub const fn get_ONE_IF(&self) -> Option<&FlagIfElseIfUpdateFlagONE_IF> {
        self.one_if.as_ref()
    }

    pub fn clear_ONE_IF(mut self) -> Self {
        self.inner &= UpdateFlag::ONE_IF.reverse_bits();
        self.one_if = None;
        self
    }

    pub const fn new_EIGHT_IF(eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        Self {
            inner: UpdateFlag::EIGHT_IF,
            one_if: None,
            eight_if: Some(eight_if),
        }
    }

    pub fn set_EIGHT_IF(&mut self, eight_if: FlagIfElseIfUpdateFlagEIGHT_IF) -> Self {
        self.inner |= UpdateFlag::EIGHT_IF;
        self.eight_if = Some(eight_if);
        self.clone()
    }

    pub const fn get_EIGHT_IF(&self) -> Option<&FlagIfElseIfUpdateFlagEIGHT_IF> {
        self.eight_if.as_ref()
    }

    pub fn clear_EIGHT_IF(mut self) -> Self {
        self.inner &= UpdateFlag::EIGHT_IF.reverse_bits();
        self.eight_if = None;
        self
    }

    pub(crate) const fn as_int(&self) -> u8 {
        self.inner
    }

}
impl FlagIfElseIfUpdateFlag {
    pub(crate) fn size(&self) -> usize {
        1 // inner
        + {
            if let Some(s) = &self.one_if {
                s.size()
            } else {
                0
            }
        }
        + {
            if let Some(s) = &self.eight_if {
                s.size()
            } else {
                0
            }
        }
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct FlagIfElseIfUpdateFlagEIGHT_IF {
    pub last_if: u8,
}

impl FlagIfElseIfUpdateFlagEIGHT_IF {
    pub(crate) fn size(&self) -> usize {
        1 // last_if: u8
    }
}

